/* Auto-generated by cbindgen - do not edit manually */

#ifndef BINDLE_H
#define BINDLE_H

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>
#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>

typedef enum BindleCompress {
  BindleCompressNone,
  BindleCompressZstd,
  BindleCompressAuto,
} BindleCompress;

typedef struct Bindle Bindle;

typedef struct BindleReader BindleReader;

typedef struct BindleWriter BindleWriter;

/**
 * Open a bindle file from disk, the path paramter should be NUL terminated
 */
struct Bindle *bindle_open(const char *path);

/**
 * Adds a new entry, the name should be NUL terminated, will the data can contain NUL characters since the length
 * is provided
 */
bool bindle_add(struct Bindle *ctx,
                const char *name,
                const uint8_t *data,
                size_t data_len,
                enum BindleCompress compress);

/**
 * Adds a new entry, the name should be NUL terminated, will the data can contain NUL characters since the length
 * is provided
 */
bool bindle_add_file(struct Bindle *ctx,
                     const char *name,
                     const char *path,
                     enum BindleCompress compress);

/**
 * Save any changed to disk
 */
bool bindle_save(struct Bindle *ctx);

/**
 * Close an open bindle file
 */
void bindle_close(struct Bindle *ctx);

/**
 * Read a value from a bindle file in memory, returns a pointer that should be freed with
 * `bindle_free_buffer`
 */
uint8_t *bindle_read(struct Bindle *ctx_ptr, const char *name, size_t *out_len);

/**
 * Used to free the results from `bindle_read`
 */
void bindle_free_buffer(uint8_t *ptr);

/**
 * Directly read an uncompressed entry from disk, returns NULL if the entry is compressed or doesn't exist
 */
const uint8_t *bindle_read_uncompressed_direct(struct Bindle *ctx,
                                               const char *name,
                                               size_t *out_len);

/**
 * Get the number of entries in a bindle file
 */
size_t bindle_length(const struct Bindle *ctx);

/**
 * Returns the name of the entry at the given index.
 * The string is owned by the Bindle; the caller must NOT free it.
 */
const char *bindle_entry_name(const struct Bindle *ctx, size_t index, size_t *len);

/**
 * Compact and rewrite bindle file
 */
bool bindle_vacuum(struct Bindle *ctx);

bool bindle_unpack(struct Bindle *ctx, const char *dest_path);

bool bindle_pack(struct Bindle *ctx, const char *src_path, enum BindleCompress compress);

bool bindle_exists(const struct Bindle *ctx, const char *name);

/**
 * Create a new Writer, while the stream is active (until bindle_stream_finish is called), the
 * Bindle struct should not be accessed.
 */
struct BindleWriter *bindle_writer_new(struct Bindle *ctx,
                                       const char *name,
                                       enum BindleCompress compress);

bool bindle_writer_write(struct BindleWriter *stream, const uint8_t *data, size_t len);

bool bindle_writer_finish(struct BindleWriter *stream);

struct BindleReader *bindle_reader_new(const struct Bindle *ctx, const char *name);

ptrdiff_t bindle_reader_read(struct BindleReader *reader, uint8_t *buffer, size_t buffer_len);

void bindle_reader_free(struct BindleReader *reader);

#endif  /* BINDLE_H */
